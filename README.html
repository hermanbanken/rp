<!DOCTYPE html>
<html>
<head>
  <title>Reactive Programming</title>
  <link rel="stylesheet" type="text/css" href="GitHub2.css">
  <link rel="stylesheet" type="text/css" href="app.css">
  <link rel="stylesheet" type="text/css" href="bower_components/prism/themes/prism.css">
  <script src="bower_components/jquery/dist/jquery.min.js"></script>
  <script src="bower_components/rxjs/dist/rx.all.js"></script>
  <script src="bower_components/prism/prism.js"></script>
  <script src="bower_components/d3/d3.min.js"></script>
  <script src="lib.js"></script>
</head>

<body>
<h1>Reactive Programming
<small>by Herman Banken</small>
</h1>

<p>"Reactive Programming is a new term", were the first words of a <a href="http://www.jstor.org/stable/1235239?seq=2#page_scan_tab_contents">paper from 1959</a>, in the Journal of Farm Economics. The author was speaking about a mathematical concept however and had little to do with the definition "Reactive Programming" in the context of programming languages, first mentioned in 1989 by Berry:</p>

<blockquote><p>"Reactive programs continuously interact with their environment, at a speed determined by the environment instead of the program itself." - GÃ©rard Berry, 1989</p></blockquote>

<p>The term "reactive" seems hotter than ever, and curiously people still think that it is something new. In 2015 Andre Staltz wrote "[..] this new thing called Reactive Programming" and he is not the only one: it is new to more and more people. But Reactive Programming (RP) exists in many different shapes, and it is important to know the differences.</p>

<p>After working with Reactive technologies for some time it becomes natural, but it can be a hard concept to grasp. In this blog I will try to get you up to speed on the general subject and explain the different types of languages and frameworks, so you can use it too.</p>

<p>The following frameworks will be used in samples, and some of their strengths and peculiarities are discussed, in order of character count:</p>
<ul>
  <li><a href="">Elm</a></li>
  <li><a href="https://meteor.com">Meteor</a></li>
  <li><a href="https://github.com/ingoem/scala-react">Scala.React</a></li>
  <li><a href="http://www.reactive-streams.org/">Reactive Streams</a></li>
  <li><a href="http://reactivex.io/">Reactive Extensions</a></li>
</ul>

<h2>Events and Behaviours</h2>

<p>
At the core of <a href="">classical functional reactive programming</a> are the concepts of Events and Behaviours.
When writing a reactive application your program is generally interacted with by humans or remote systems. These interactions trigger events in the system, which allow the system to process new information, recompute or update the UI for example.
Formally events represent a sequence of discrete events as a timestamped list of values:</p>

<p><center>Events &alpha; = [(Time, &alpha;)]</center></p>

<p>
Behaviours are continuous and time-varying values. For example analog position, velocity or acceleration, the temperature, or time itself, are behaviours. They can be represented as a function from time to a value:
</p>

<p><center>Behaviour &alpha; = Time &#8594; &alpha;</center></p>

<p>
There exists an isomorphism between Events and Behaviours, as shown by 
<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.63.4658&amp;rep=rep1&amp;type=pdf">Hudak et al.</a>, 
converting form discrete to continuous time:
</p>

<p><center>Event &alpha; &#8776; Behaviour ( Maybe &alpha; )</center></p>

<p>
When viewed from a more practical viewpoint the reverse also holds. 
Continuous values, behaviours, when modeled in the computer are really discrete values or samples, so Behaviours are represented as very fast firing Events.
There is an actual maximum frequency at which the data is needed:
the input is received only at the sample speed of the sensors and 
the system can only display the results to the screen at a maximum of the refresh rate of the monitor or a given output rate to other outputs.
</p>

<svg id="continuous-discrete" style="width:100%"></svg>

<p>
This even allows for some optimization: by not firing an event when the sampled value did not change, we can prevent unnecessary recomputations.
</p>

<svg id="discrete-optimize" style="width:100%"></svg>

<h2>Signal</h2>
Generalising these events and behaviours we can represent them in a common data type, a <em>signal</em>.

<p><center>Signal &alpha; = Time &#8594; &alpha;</center></p>

<p>
Such a signal represents a value at each particular time. 
To be useful, signals can be transformed, and combined, 
into new signals.
</p>

<h3>Transparent combinators</h3>
<p>
It depends on the language or framework what operations are
allowed and how to use them. Utilizing a very expressive
language we can write these transformed or composed signals 
very neatly.
In the example below the temperature can be a sensor or 
a remote (streaming) API. This input produces new values, 
which get then instantly converted to another unit-system 
and displayed.
</p>

<div data-code="signal-compose"></div>

<p>
Both these examples are written using a very expressive framework. Meteor and Scala.React both track dependencies: when the function <code>tempC</code> is executed the depencency on <code>Temperature</code> is registered. The framework now knows that if <code>Temperature</code> changes the <code>tempC</code> function should be re-evaluated too, and consequetively the UI should be updated as well.
</p>

<p>
In the Meteor sample Tracker.autorun is used, <a href="#meteor-tracker">discussed below</a>. In the Scala.React sample the Signal function is applied a block function, represented by the curly braces, which is executed in a similar fashion as Meteor's Tracker.autorun.
</p>

<h3>Explicit combinators</h3>

<p>
Less transparent - but more powerful - frameworks like Reactive Extensions and Elm define special operators for combining multiple signals or "folding over the past".
Combining 
</p>

lift, lift2, lift3, ... <br>
foldp


<h2>Reactive Extensions example</h2>
<p>
In Reactive Programming there is external interaction with the system. For example your program could be notified of a form submit:
</p>

<div data-code="sample-1"></div>

This is a simple example, but things get complicated easily. 
For example, when this form is a search form, with live updates, over AJAX.
Of course we do not want to overload the server and do requests that are not necessary: we should debounce the keypresses. 
For example with a timeout. 
Furthermore we need to make sure that only the last search gets displayed, 
and not have a search that got delayed overwrite a more recent one.

<div data-code="sample-2"></div>

A lot is happening in this sample, and you can see that the traditional style sample becomes cluttered already. 
A lot of state is exposed, and almost nothing of the code is reusable. 
In contrast to the Rx example which is really expressive, clean and reusable. 
On the other hand in the Rx example we see some operators that might seem a little magical at first:

<ul>
  <li>
    <a>pluck</a> extracts fields from objects. 
    <code class="language-js">pluck('target', 'value')</code> simply means that
    <code class="language-js">input['target']['value']</code> is extracted,
  </li>
  <li><a href="http://reactivex.io/documentation/operators/debounce.html">debounce</a> delays all subsequent actions, and ignores events that are followed with another event within that delay,</li>
  <li><a href="http://reactivex.io/documentation/operators/distinct.html">distinctUntilChanged</a> only propagates events if the value changed,</li>
  <li><a href="http://reactivex.io/documentation/operators/flatmap.html">flatMap</a> accepts a function which returns an Observable itself, so for each event a stream of events is created, and merged into a single stream as a result. 
  The flatMapLatest function is a special kind of flatMap, which makes sure only the last input event generates output events, canceling previous event streams.</li>
</ul>

<p>
Update &amp; check loop<br/>
System controlled by environment<br/>
Callback hell
 </p>

<p>Dual of iterator</p>

<h2>Push vs pull</h2>

<h2>Code style: transparent/explicit</h2>

<h2>Pure? Functional?</h2>

<h2>Glitches</h2>

<h2>Hot 'n Cold</h2>

<h1>Extra's</h1>

<p>Bonus goodies :)</p>

<h2>Rx's Duality to Enumerable</h2>

<h2 id="meteor-tracker">Meteor's <code>Tracker.autorun</code></h2>
<p>
In earlier Meteor samples we consumed a reactive value, transformed it and displayed it. This example shows how to create such a reactive value in Meteor, using the <code>Tracker</code> package. Tracker is a dependency tracker, building a graph of dependencies between reactive values. If a change is triggered at a node in the graph 
all downstream nodes are tested and updated, triggering further updates if their values change too.
</p>

<p>
Creating a new dependency in Meteor is simple: first  create a <code class="language-js">new Tracker.Dependency</code>. Then create a function you want to be re-evaluated when the reactive values change: wrap it in <code>Tracker.autorun</code>. The Tracker.Dependency object reports calls to it's <code>depend</code> and <code>changed</code> functions to the framework. When a function wrapped in <code>autorun</code> hits a <code>depend</code>-call during execution, a dependency is tracked between the wrapped function and the Dependency-object. Any calls to the <code>changed</code> function later on trigger a re-evaluation.
</p>

<p>A good pattern is to have a getter, that calls <code>depend()</code> and a setter, that calls <code>changed()</code>, encapsulating the variable that is mutable. This way it is clear how the variable can be changed, and when a re-evaluation is triggered.</p>

<p>What's better to explain this than code:</p>
<div data-code="deps"></div>

A nice thing about Tracker is that intermediary code does not need to be aware of the reactive code. If the provider (time, database, interactions, etc.) and the consumer (template language like Blaze) handle the Tracker-code all transformations in between need not be aware of any reactivity. You can write your code just if it were executed once, but get auto-updating for free.

<script src="app.js"></script>
<script src="continuous.discrete.js"></script>
<script src="discrete.optimize.js"></script>
</body></html>