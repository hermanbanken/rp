<!--
- gentle intro without too much giveaway's
- basic abstractions
    events, behaviours, signal, observable, discrete, continuous
- evaluation model
    push vs pull
- glitch avoidance, dependency tracking, rounds
- lifting
-->
<!DOCTYPE html>
<html>
<head>
  <title>Reactive Programming</title>
  <link rel="stylesheet" type="text/css" href="GitHub2.css">
  <link rel="stylesheet" type="text/css" href="app.css">
  <link rel="stylesheet" type="text/css" href="bower_components/prism/themes/prism.css">
  <script type="text/javascript" src="bower_components/jquery/dist/jquery.min.js"></script>
  <script type="text/javascript" src="bower_components/prism/prism.js"></script>
  <script type="text/javascript" src="bower_components/d3/d3.min.js"></script>
  <script type="text/javascript" src="dist/rp.browser.js"></script>
</head>

<body>
<h1>Reactive Programming
<small>by Herman Banken</small>
</h1>

<p>
"Reactive Programming is a new term", were the first words of a 
<a href="http://www.jstor.org/stable/1235239?seq=2#page_scan_tab_contents">paper from 1959</a>, 
in the Journal of Farm Economics. The author was speaking about a mathematical concept however. 
It had little to do with the definition "Reactive Programming" in the context of programming languages, 
first mentioned in 1989 by Berry:
</p>

<blockquote><p>
	"Reactive programs continuously interact with their environment, 
	at a speed determined by the environment instead of the program itself." - GÃ©rard Berry, 1989
</p></blockquote>

<p>
The term "reactive" seems hotter than ever, and curiously people still think that it is something new. 
In 2015 Andre Staltz wrote "[..] this new thing called Reactive Programming" and he is not the only one: 
it is new to more and more people. But Reactive Programming (RP) exists in many different shapes, 
and it is important to know the differences to get the right tool for the job.
After working with Reactive technologies for some time it becomes natural, 
but it can be a hard concept to grasp at first.
In this blog I will try to get you up to speed on the general subject and explain the different types of 
languages and frameworks, so you can use it too.</p>

<p>
	The following frameworks will be used in samples, 
	and some of their strengths and peculiarities are discussed, 
	in order of character count:
<a href="">Elm</a>, 
<a href="https://meteor.com">Meteor</a>, 
<a href="https://github.com/ingoem/scala-react">Scala.React</a>, 
<a href="http://www.reactive-streams.org/">Reactive Streams</a> and 
<a href="http://reactivex.io/">Reactive Extensions</a>.
</p>

<h2>Reactive Programming</h2>
<p>
Shifting away from traditional batch based programs and towards interactive applications, 
possibly handling large amounts of live data, we as developers needed a new toolchain. 
Traditionally we would gather all data, put it into a computer and it would run over night, 
hopefully being done in the morning.
Nowadays we get new data constantly and want it processed immediatly, updating the output instantly. 
We also make more interactive applications, handling more sorts of inputs. 
Next to just clicks, our phones now have sensors to register all kinds of inputs. 
The speed at which the program needs to work is determined by the environment, 
as with <em>reactive</em> programs, in contrast to traditional <em>transformational</em> programs.
</p>

<p>
With reactive programming you can write more comprehensible code,
because you can model the data-flow instead of passing the data around manually.
You descibe 
 what happens when new parts of data arrive,
 define through which transformations the data should go, 
 and which output gets generated in response to the input.
At the basis of reactive programming lie abstractions and primitives that
conceptualize these inputs and the operations you can perform.
</p>

<h2>The beginning</h2>
<p>
Reactive Programming was first mentioned in research about Real-Time and Reactive Systems 
in the context of data-flow programming and the development of <a href="https://en.wikipedia.org/wiki/Esterel">Esterel</a>, 
by Gerard Berry and his team (see papers from <a href="https://hal.inria.fr/inria-00075494/document">1989</a> &amp; <a href="https://hal.inria.fr/inria-00075115/document">1991</a>).
They noted that then existing General Purpose Languages (GPL's) alone were not suitable for those systems,
and that development could benefit from better abstractions and primitives 
available in Special Purpose Languages, like Esterel.
He argues for synchronity as it allows focussing on the logic of reactions, 
instead of dealing with the problems that arrise with asynchronity. 
Synchronity makes deterministic and concurrent programs possible and causes performance to be predictable, 
which is neccessary for real time systems.
He concludes that GPL's and SPL's respective advantages are complementary 
and can be combined in larger systems.
</p>

<p>
In 1997 Elliot and Hudak use a functional rather than imperative style for their Reactive Animation system 
<a href="http://www.eecs.northwestern.edu/~robby/courses/395-495-2009-winter/fran.pdf">Fran</a>.
Being the first FRP framework, Fran is often referred to as classic functional reactive programming (Classic FRP).
It provided a basis for future research into (functional) reactive programming by creating the notion of
events and behaviours.
</p>

<h2>Abstractions: Events and Behaviours</h2>

<p>
At the core of Classic FRP  are the concepts of <em>Events</em> and <em>Behaviours</em>.
When writing a reactive application your program is generally interacted with by humans or remote systems. 
These interactions trigger events in the system, which allow the system to process new information, 
recompute or update the UI for example.
Formally events represent a sequence of discrete events as a timestamped list of values:</p>

<p><center>Events &alpha; = [(Time, &alpha;)]</center></p>

<p>
Behaviours are continuous and time-varying values. 
For example analog position, velocity or acceleration, the temperature, or time itself, are behaviours. 
They can be represented as a function from time to a value:
</p>

<p><center>Behaviour &alpha; = Time &#8594; &alpha;</center></p>

<p>
There exists an isomorphism between Events and Behaviours, as shown by 
<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.63.4658&amp;rep=rep1&amp;type=pdf" title="Real-Time FRP - Wan, Taha, Hudak">Hudak et al.</a>, 
converting from discrete to continuous time:
</p>

<p><center>Event &alpha; &#8776; Behaviour ( Option &alpha; )</center></p>

<p>Here 
	<abbr title="here Option/Some/None, but actually called Maybe/Just/Nothing in the original paper">Option</abbr> 
	is an abstract data type, being either Some &alpha; or None. 
	This isomorphism simplifies the semantics: 
	we can now represent both behaviours and events in a common data type, named a <em>Signal</em>:</p>

<p><center>Signal &alpha; = Time &#8594; &alpha;</center></p>

<p>
The isomorphism also holds in reverse, when viewed from a more practical viewpoint. 
Continuous values, behaviours, when modeled in the computer are really discrete values or samples, 
so Behaviours are represented as very fast firing Events.
There is an actual maximum frequency at which the data is needed: 
first the input is received only at the sample speed of the sensors and 
second the system can only display the results to the screen 
at a maximum of the refresh rate of the monitor or a given output rate to other outputs.
</p>

<svg id="continuous-discrete" style="width:100%"></svg>

<p>
This even allows for some optimization: by not firing an event when the sampled value did not change, we can prevent unnecessary recomputations.
</p>

<svg id="discrete-optimize" style="width:100%"></svg>

<h3>Different names</h3>
<p>
Every Reactive framework or language developed after Fran tends to ship with it's own terms for very comparable concepts.
Of course the differences are what make the frameworks special or more useful to a specific case,
but the idea of the underlying abstractions is the same.
Classic FRP and it's direct derivatives have behaviours and events, 
while most recent frameworks have only the concept of discrete events.
</p>

<table>
  <tr><th></th><th>Event</th><th>Behaviour</th></tr>
  <tr><td>Classic FRP</td><td>Event</td><td>Behaviour</td></tr>
  <tr><td>Elm</td><td>Signal</td><td></td></tr>
  <tr><td>Rx</td><td>Observable</td><td></td></tr>
  <tr><td>Reactive Streams</td><td>Signal</td><td></td></tr>
</table>

<h3>Semantics</h3>
<p>
The semantics of Events and Behaviours are well defined 
in Elliots paper <a href="http://conal.net/papers/push-pull-frp/push-pull-frp.pdf">Push-Pull Functional Reactive Programming</a>.
The original definitions and primitives are replaced by common classes and methods where possible, 
giving the semantics of the Event and Behavior instances of Functor, Applicative Functor, Monoid and Monad, when they exist.   
</p>
<span class="todo">TODO: More here about Monad, AF instances, why useful. Maybe why Elm not AF, for safeness and more reasoning power?</span>

<h2>Combinators</h2>

<h3>Transparent combinators</h3>
<p>
It depends on the language or framework what operations are
allowed and how to use them. Utilizing a very expressive
language we can write these transformed or composed signals 
very neatly.
In the example below the temperature can be a sensor or 
a remote (streaming) API. This input produces new values, 
which get then instantly converted to another unit-system 
and displayed.
</p>

<div data-code="signal-compose"></div>

<p>
Both these examples are written using a very expressive framework. Meteor and Scala.React both track dependencies: when the function <code>tempC</code> is executed the depencency on <code>Temperature</code> is registered. The framework now knows that if <code>Temperature</code> changes the <code>tempC</code> function should be re-evaluated too, and consequetively the UI should be updated as well.
</p>

<p>
In the Meteor sample Tracker.autorun is used, <a href="#meteor-tracker">discussed below</a>. In the Scala.React sample the Signal function is applied a block function, represented by the curly braces, which is executed in a similar fashion as Meteor's Tracker.autorun.
</p>

<h3>Explicit combinators</h3>

<p>
Less transparent - but more powerful - frameworks like Reactive Extensions and Elm define special operators for combining multiple signals or "folding over the past".
Combining 
</p>

<span class="todo">
	TODO: lift, lift2, lift3, ... <br>
	foldp
</span>



<h2>Reactive Extensions example</h2>
<p>
In Reactive Programming there is external interaction with the system. For example your program could be notified of a form submit:
</p>

<div data-code="sample-1"></div>

This is a simple example, but things get complicated easily. 
For example, when this form is a search form, with live updates, over AJAX.
Of course we do not want to overload the server and do requests that are not necessary: we should debounce the keypresses. 
For example with a timeout. 
Furthermore we need to make sure that only the last search gets displayed, 
and not have a search that got delayed overwrite a more recent one.

<div data-code="sample-2"></div>

A lot is happening in this sample, and you can see that the traditional style sample becomes cluttered already. 
A lot of state is exposed, and almost nothing of the code is reusable. 
In contrast to the Rx example which is really expressive, clean and reusable. 
On the other hand in the Rx example we see some operators that might seem a little magical at first:

<ul>
  <li>
    <a>pluck</a> extracts fields from objects. 
    <code class="language-js">pluck('target', 'value')</code> simply means that
    <code class="language-js">input['target']['value']</code> is extracted,
  </li>
  <li><a href="http://reactivex.io/documentation/operators/debounce.html">debounce</a> delays all subsequent actions, and ignores events that are followed with another event within that delay,</li>
  <li><a href="http://reactivex.io/documentation/operators/distinct.html">distinctUntilChanged</a> only propagates events if the value changed,</li>
  <li><a href="http://reactivex.io/documentation/operators/flatmap.html">flatMap</a> accepts a function which returns an Observable itself, so for each event a stream of events is created, and merged into a single stream as a result. 
  The flatMapLatest function is a special kind of flatMap, which makes sure only the last input event generates output events, canceling previous event streams.</li>
</ul>

<p class="todo">
Update &amp; check loop<br/>
System controlled by environment<br/>
Callback hell
 </p>

<p>Dual of iterator</p>

<h2>Push vs pull, the evaluation model</h2>
<p>
Each reactive programming language or framework has an <em>evaluation model</em>, responsible for propagating changes. This evaluation model of a reactive system is mostly hidden to the user, but it influences the performance and the capabilites that the system offers.
Choosing the right language or framework thus requires at least some knowledge of the internal evaluation models. Generally two paradigms exist: <em>push</em> and <em>pull</em>. In this section we explains both their advantages and disadvantages, and use cases.  
</p>
<p>
When propagating changes in a reactive system, either of the two parties can be in charge of initiating the propagation. Either the sources send (push) values to their dependants or the dependants request (pull) the values from their sources. Don't be confused: the data always originates at the source and flows to destination, but who is responsible is what changes.
</p>
<p>
<em>Push</em> based reactive systems propagate changes to subscribers as soon as new data arrives. It is <em>data-driven</em>. To achieve this, such a system let subscibers register with the source or observable to receive updates first. The source then remembers who is subscribed. Later, when a source changes, it pushes an update to all dependants. There is nothing the dependant can do to stop this, except unregistering. This conforms to the original definition of Reactive Programming: the dependant operates at the speed of the environment providing new data. This ensures the fasted delivery possible: whenever new data is available it reaches the destination. A disadvantage is that the programmer needs to make sure that processing the change is fast, virtually instant. Luckily frameworks generally implement ways to deduplicate, buffer or drop superfluous changes. Push based systems work best when changes have a discrete character, for example clicks or tweets, and there is no sample rate that is seriously limiting the main effect. Push based it more suitable for updating a database or application UIs than for example the game loop of a 60fps 3d shooter game.
</p>
<p>
<em>Pull</em> based systems propagate changes whenever the subscriber requires new data. They are <em>demand-driven</em>. The first Functional Reactive Programming languages (<a href="http://conal.net/fran/">Fran</a>) were pull based. It matches well with the concept of a Behaviour, a continuous function: continuous functions need to be sampled to visualize them on a screen or write them to disk. When a new sample is started each value requests the values of it's upstream dependencies. This ensures no wastefull computations are done in-between samples, but also introduces a delay between changes and their effect: on average half the sample rate and in the worst case the full sample rate.
</p>
<p>
It can be argued that pull based systems are not 'reactive' in the sense of the original definition: the subscriber is in charge of requesting new data, so it is possible that the system does not operate at the speed of the environment. Depending on the use case this can be a good thing, but in most use cases for Reactive Programming pull-based systems theoretically offer better performance.
</p>

<h3>Pull the trigger</h3>
<p>
The evaluation model is really about which party triggers change to be propagated, but there is another distinction: how the change is propagated. In frameworks that utilise a subscriber pattern the change is pushed to the subscribers, providing them with a new value. This is in contrast to frameworks that operate on a dependency graph, which trigger recomputation of a part of this graph, by retrieving the input values and performing the computation, triggering changes further down the graph.
</p>

<h2>Code style: transparent/explicit</h2>

<h2>Pure? Functional?</h2>

<h2>Glitches</h2>

<h2>Hot 'n Cold</h2>

<h1>Extra's</h1>

<p>Bonus goodies :)</p>

<h2>Rx's Duality to Enumerable</h2>

<h2 id="meteor-tracker">Meteor's <code>Tracker.autorun</code></h2>
<p>
In earlier Meteor samples we consumed a reactive value, transformed it and displayed it. This example shows how to create such a reactive value in Meteor, using the <code>Tracker</code> package. Tracker is a dependency tracker, building a graph of dependencies between reactive values. If a change is triggered at a node in the graph 
all downstream nodes are tested and updated, triggering further updates if their values change too.
</p>

<p>
Creating a new dependency in Meteor is simple: first  create a <code class="language-js">new Tracker.Dependency</code>. Then create a function you want to be re-evaluated when the reactive values change: wrap it in <code>Tracker.autorun</code>. The Tracker.Dependency object reports calls to it's <code>depend</code> and <code>changed</code> functions to the framework. When a function wrapped in <code>autorun</code> hits a <code>depend</code>-call during execution, a dependency is tracked between the wrapped function and the Dependency-object. Any calls to the <code>changed</code> function later on trigger a re-evaluation.
</p>

<p>A good pattern is to have a getter, that calls <code>depend()</code> and a setter, that calls <code>changed()</code>, encapsulating the variable that is mutable. This way it is clear how the variable can be changed, and when a re-evaluation is triggered.</p>

<p>What's better to explain this than code:</p>
<div data-code="deps"></div>

A nice thing about Tracker is that intermediary code does not need to be aware of the reactive code. If the provider (time, database, interactions, etc.) and the consumer (template language like Blaze) handle the Tracker-code all transformations in between need not be aware of any reactivity. You can write your code just if it were executed once, but get auto-updating for free.

</body></html>